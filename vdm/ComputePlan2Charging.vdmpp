class ComputePlan2Charging is subclass of RoverTypes

-- 充電ステーションへの移動プランを生成するクラス
-- 最寄りの充電器を探索し、そこへの経路を計算する

instance variables
    -- ゴール推論エージェントへの参照
    private gra : [GoalReasoningAgent] := nil;
    
    -- 最後に生成されたプラン
    private lastPlan : [Plan] := nil;
    
    -- 最後のプラン生成ステータス
    private lastStatus : PlanStatus := <NoPlan>;
    
    -- 故障モードシミュレーション用フラグ
    private failureActive : bool := false;
    
    -- シミュレートする故障の種類
    private failureReason : Fault := <PlannerTimeout>;
    
    -- 故障時のシステム状態
    private failureState : SystemState := mk_SystemState(0, true, nil);

operations
    -- ゴール推論エージェントを設定する
    public setGoalAgent : GoalReasoningAgent ==> ()
    setGoalAgent(agent) == gra := agent;

    -- 故障モードを有効化/無効化する（テスト用）
    public setFailureMode : bool ==> ()
    setFailureMode(flag) == failureActive := flag;

    -- 故障時の応答を設定する（テスト用）
    public configureFailureResponse : Fault * SystemState ==> ()
    configureFailureResponse(reason, state) ==
    (
        failureReason := reason;
        failureState := state
    );

    -- 充電プラン生成を要求する
    -- 引数 obstacles: 障害物集合
    -- 引数 chargers: 充電器リスト
    -- 戻り値: プラン生成ステータス
    -- 事後条件: 
    --   Readyなら有効なプランが生成されていること
    --   Failure/NoPlanならプランはnilであること
    public requestPlan : set of RoverTypes`Position * seq of Charger ==> PlanStatus
    requestPlan(obstacles, chargers) ==
    (
        if gra = nil
        then (
            lastPlan := nil;
            lastStatus := <Failure>;
            return lastStatus
        )
        else (
            dcl currentGoalOpt : [Goal] := gra.getCurrentGoal();
            if failureActive
            then (
                lastPlan := nil;
                lastStatus := <Failure>;
                gra.plannerFeedback(<Charging>, lastStatus);
                gra.notifyFailure(failureReason, failureState);
                return lastStatus
            )
            else skip;
            if currentGoalOpt = nil
            then (
                lastPlan := nil;
                lastStatus := <NoPlan>;
                gra.plannerFeedback(<Charging>, lastStatus);
                return lastStatus
            )
            else (
                dcl goal : Goal := currentGoalOpt;
                dcl chargerSet : set of Charger := { c | c in set elems chargers };
                dcl nearest : [Charger] := nearestCharger(goal.pos, chargerSet);
                if nearest = nil
                then (
                    lastPlan := nil;
                    lastStatus := <NoPlan>;
                    gra.plannerFeedback(<Charging>, lastStatus);
                    return lastStatus
                )
                else (
                    if exists obs in set obstacles & sameLocation(obs, nearest.pos)
                    then (
                        lastPlan := nil;
                        lastStatus := <NoPlan>;
                        gra.plannerFeedback(<Charging>, lastStatus);
                        return lastStatus
                    )
                    else (
                        if sameLocation(goal.pos, nearest.pos)
                        then lastPlan := mk_Plan([])
                        else lastPlan := mk_Plan([goal.pos, nearest.pos]);
                        lastStatus := <Ready>;
                        gra.plannerFeedback(<Charging>, lastStatus);
                        return lastStatus
                    )
                )
            )
        )
    )
    post 
        let status = RESULT in
        (status = <Ready> => lastPlan <> nil) and
        (status = <Failure> => lastPlan = nil) and
        (status = <NoPlan> => lastPlan = nil);

    -- 最後に生成されたプランを取得する
    public getLastPlan : () ==> [Plan]
    getLastPlan() == return lastPlan;

    -- 最後のステータスを取得する
    public getLastStatus : () ==> PlanStatus
    getLastStatus() == return lastStatus;

end ComputePlan2Charging
