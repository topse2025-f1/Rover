class VisionSpecificationTests is subclass of RoverTypes

types
    public TestResult ::
        name : seq of char
        passed : bool
        details : seq of char;

    public VisionPosition = RoverTypes`Position;
    public VisionSensorReading = Vision`SensorReading;

functions
    private mkResult : seq of char * bool * seq of char -> TestResult
    mkResult(name, passed, details) ==
        mk_TestResult(name, passed, details)
    pre name <> [] and details <> [];

instance variables
    private vision : Vision := new Vision();

operations
    private ResetVision: () ==> ()
    ResetVision() ==
        vision := new Vision();

    private RegisterNominalReadings: () ==> ()
    RegisterNominalReadings() ==
    (
        dcl camera1 : Vision`SensorReading := mk_Vision`SensorReading(<Camera>, [mk_RoverTypes`Position(0.0, 0.0), mk_RoverTypes`Position(2.0, 0.0)]);
        dcl lidar1 : Vision`SensorReading := mk_Vision`SensorReading(<LiDAR>, [mk_RoverTypes`Position(0.0, 2.0), mk_RoverTypes`Position(2.0, 2.0)]);
        vision.updateSensor(mk_token("camera-1"), camera1);
        vision.updateSensor(mk_token("lidar-1"), lidar1)
    );

    private EstimateFromPoints: seq of VisionPosition ==> VisionPosition
    EstimateFromPoints(points) ==
    (
        ResetVision();
        vision.updateSensor(mk_token("sensor-temp"), mk_Vision`SensorReading(<Camera>, points));
        vision.processSensorData();
        return vision.getCurrentPosition()
    )
    pre len points > 0;

    public TestV1_SupportsCameraAndLiDAR: () ==> TestResult
    TestV1_SupportsCameraAndLiDAR() ==
    (
        ResetVision();
        vision.updateSensor(mk_token("camera-V1"), mk_Vision`SensorReading(<Camera>, [ mk_RoverTypes`Position(0.0, 0.0), mk_RoverTypes`Position(2.0, 0.0) ]));
        vision.updateSensor(mk_token("lidar-V1"), mk_Vision`SensorReading(<LiDAR>, [ mk_RoverTypes`Position(0.0, 2.0), mk_RoverTypes`Position(2.0, 2.0) ]));
        vision.processSensorData();
        return let pos = vision.getCurrentPosition(),
                        expected = mk_RoverTypes`Position(1.0, 1.0),
                        ok = pos.x = expected.x and pos.y = expected.y
        in mkResult("V1: accept camera and LiDAR readings", ok,
            if ok
            then "processSensorData merged camera and LiDAR points"
            else "currentPosition did not match average of camera and LiDAR readings")
    );

    public TestV2_ReturnsCurrentPositionAndObstacles: () ==> TestResult
    TestV2_ReturnsCurrentPositionAndObstacles() ==
    (
        ResetVision();
        vision.updateSensor(mk_token("camera-V2"), mk_Vision`SensorReading(<Camera>, [
            mk_RoverTypes`Position(0.0, 0.0),
            mk_RoverTypes`Position(2.0, 0.0)
        ]));
        vision.updateSensor(mk_token("lidar-V2"), mk_Vision`SensorReading(<LiDAR>, [
            mk_RoverTypes`Position(0.0, 2.0),
            mk_RoverTypes`Position(2.0, 2.0)
        ]));
        vision.processSensorData();
        return let pos = vision.getCurrentPosition(),
                        obs = vision.getObstacles(),
                        expectedPos = mk_RoverTypes`Position(1.0, 1.0),
                        expectedObstacles = {
                            mk_RoverTypes`Position(0.0, 0.0),
                            mk_RoverTypes`Position(2.0, 0.0),
                            mk_RoverTypes`Position(0.0, 2.0),
                            mk_RoverTypes`Position(2.0, 2.0)
                        },
                        ok = pos = expectedPos and obs = expectedObstacles
        in mkResult("V2: returns position and obstacle set", ok,
            if ok
            then "currentPosition and obstacle set match expected values"
            else "currentPosition or obstacle set deviates from expected aggregate values")
    );

    public TestV3_AccuracyThreshold: () ==> TestResult
    TestV3_AccuracyThreshold() ==
    (
        ResetVision();
        RegisterNominalReadings();
        vision.processSensorData();
    return let res = vision.assertDetectionAccuracy()
           in mkResult("V3: accuracy >= 95%", res,
            if res
            then "assertDetectionAccuracy reports compliance"
            else "expected accuracy >= 0.95 but assertion failed")
    );

    public TestV4_PositionNotOnObstacle: () ==> TestResult
    TestV4_PositionNotOnObstacle() ==
    (
        ResetVision();
        RegisterNominalReadings();
        vision.processSensorData();
        return let pos = vision.getCurrentPosition(),
                        obs = vision.getObstacles(),
                        safe = forall o in set obs & RoverTypes`dist(pos, o) >= 1.0
        in mkResult("V4: current position avoids obstacles", safe,
            if safe
            then "no obstacle found within safety distance"
            else "detected obstacle closer than 1m to current position")
    );

    public TestV5_PositionTolerance: () ==> TestResult
    TestV5_PositionTolerance() ==
    (
        ResetVision();
        RegisterNominalReadings();
        vision.processSensorData();
        return let truePos = mk_RoverTypes`Position(0.5, 1.2),
                        res = vision.assertPositionTolerance(truePos)
        in mkResult("V5: within +/-2m of true position", res,
            if res
            then "assertPositionTolerance confirmed tolerance"
            else "estimated position outside +/-2m tolerance")
    );

    public TestV5_NegativeCase: () ==> TestResult
    TestV5_NegativeCase() ==
    (
        ResetVision();
        RegisterNominalReadings();
        vision.processSensorData();
        return let truePos = mk_RoverTypes`Position(10.0, 10.0),
                        res = vision.assertPositionTolerance(truePos)
        in mkResult("V5: tolerance violation detected", not res,
            if not res
            then "assertPositionTolerance correctly rejected far true position"
            else "expected tolerance check to fail for far true position")
    );

    public TestV6_LocalRobustness: () ==> TestResult
    TestV6_LocalRobustness() ==
    (
        dcl basePos : VisionPosition := EstimateFromPoints([
            mk_RoverTypes`Position(0.0, 0.0),
            mk_RoverTypes`Position(2.0, 0.0)
        ]);
        dcl perturbedPos : VisionPosition := EstimateFromPoints([
            mk_RoverTypes`Position(0.0, 0.0),
            mk_RoverTypes`Position(2.0, 0.1)
        ]);
        return let deltaX = abs(basePos.x - perturbedPos.x),
                        deltaY = abs(basePos.y - perturbedPos.y),
                        robust = deltaX <= 0.05 and deltaY <= 0.05
        in mkResult("V6: robust to small perturbations", robust,
            if robust
            then "position estimate changed by at most 0.05 for small input perturbation"
            else "position estimate moved more than 0.05 after small input perturbation")
    );

    public RunAll: () ==> seq of TestResult
    RunAll() ==
    (
        return [
            TestV1_SupportsCameraAndLiDAR(),
            TestV2_ReturnsCurrentPositionAndObstacles(),
            TestV3_AccuracyThreshold(),
            TestV4_PositionNotOnObstacle(),
            TestV5_PositionTolerance(),
            TestV5_NegativeCase(),
            TestV6_LocalRobustness()
        ]
    );

end VisionSpecificationTests
